#include <string>
#include <stack>

using namespace std;

//Converts an infix arithmetic expression into postfix
//The function takes 3 parameters
//First parameter: array of strings for infix expression
//    each string is either an integer number or operator symbol
//Second parameter: number of strings in infix expression
//Third parameter: array of strings for postfix expression
//    generated by function, same format as first parameter
//    assumes that postfix is at least the size of postfix
//Return value: int, number of strings in postfix expression
//    Returns 0 if an error is encountered when converting expression
//    An error occurs with a mismatched parenthesis, e.g. ( ( ) or ( ) ) etc.
//Operator symbols:
// ( : left parenthesis, all operations between this and ")" take place first
// ) : right parenthesis, all op.s back to previous "(" take place first
// * : multiplication, higher precedence - takes place before "+" and "-"
// / : division, higher precedence - takes place before "+" and "-"
// % : remainder, higher precedence - takes place before "+" and "-"
// + : addition, lower precedence - takes place after "*" , "/" , "%"
// - : subtraction, lower precedence - takes place after "*" , "/" , "%"
//The function is not specified to work with any other operator symbols
//Any string in infix may be assumed to be an integer operand if none
// of the above symbols


int precedence(char c){
if (c == '*' || c == '/' || c == '%')
       return 2;
   else if (c == '+' || c == '-')
       return 1;
   else
       return -1;
}

bool isInfixExpressionValid(string infix[], int length){
   stack<string> stackString;
   string x;

   for (int i = 0; i < length; i++) {
       if (infix[i][0] == '(') {
           // Push element into the stack
           stackString.push(infix[i]);
           continue;
       }

       switch (infix[i][0]) {
       case ')':
       if(stackString.empty()) {
           return 0;
       }
           x = stackString.top();
           stackString.pop(); // pop one bracket
           break;
        default:
           break;
       }
   }
   return (stackString.empty()); //if stack is not empty, then return false
}

int infixToPostfix(string infix[], int length, string postfix[]){
   
   int startIndex = 0;
   
   if (!isInfixExpressionValid(infix,length))
       return 0;

   std::stack<string> stackString;
   
   stackString.push("P");
   
   for (int i = 0; i < length; i++){
       // if string is a number then add it directly to the postfix expression
       if(isdigit(infix[i][0]))
           postfix[startIndex++] = infix[i];

       // If the scanned character is an ‘(‘, push it to the stack.
       else if (infix[i][0] == '(')
           stackString.push(infix[i]);
       
       else if (infix[i][0] == ')'){
         
           while (stackString.top()[0] != 'P' && stackString.top()[0] != '('){
               string c = stackString.top();
               stackString.pop();
               postfix[startIndex++] = c;
           }
           
           if (stackString.top()[0] == '('){
               stackString.pop();
           }
       }
       
       else {
          
           while (stackString.top()[0] != 'P' && precedence(infix[i][0]) <= precedence(stackString.top()[0])){
               string c = stackString.top();
               stackString.pop();
               postfix[startIndex++] = c;
           }
          
           stackString.push(infix[i]);
           
       }

   }
   //Pop all the remaining elements from the stack
   while (stackString.top()[0] != 'P'){
       string c = stackString.top();

       stackString.pop();
       postfix[startIndex++] = c;
   }

   return startIndex;
}

//Main function to test infixToPostfix()
//Should convert 2 + 3 * 4 + ( 5 - 6 + 7 ) * 8
//            to 2 3 4 * + 5 6 - 7 + 8 * +
int main(){
    string infixExp[] = {"2", "+", "3", "*", "4", "+", "(",
                         "5", "-", "6", "+", "7", ")", "*",
                         "8"};
    string postfixExp[15];
    int postfixLength;

    cout << "Infix expression: ";
    for (int i=0; i<15; i++){
        cout << infixExp[i] << " ";
    }
    cout << endl;
    cout << "Length: 15" << endl << endl;

    postfixLength = infixToPostfix(infixExp, 15, postfixExp);

    cout << "Postfix expression: ";
    for (int i=0; i<postfixLength; i++){
        cout << postfixExp[i] << " ";
    }
    cout << endl;
    cout << "Length: " << postfixLength << endl;
    
    return 0;
}
